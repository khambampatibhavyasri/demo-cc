name: CI/CD Pipeline

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]

jobs:
  jenkins-tests:
    name: Run Jenkins test suite
    runs-on: ubuntu-latest
    steps:
      - name: Trigger Jenkins pipeline
        env:
          JENKINS_URL: ${{ secrets.JENKINS_URL }}
          JENKINS_USER: ${{ secrets.JENKINS_USER }}
          JENKINS_API_TOKEN: ${{ secrets.JENKINS_API_TOKEN }}
          JENKINS_JOB_URL: ${{ secrets.JENKINS_JOB_URL }}
          JENKINS_BUILD_TOKEN: ${{ secrets.JENKINS_BUILD_TOKEN }}
        run: |
          set -euo pipefail
          if [ -z "${JENKINS_URL:-}" ] || [ -z "${JENKINS_USER:-}" ] || [ -z "${JENKINS_API_TOKEN:-}" ] || [ -z "${JENKINS_JOB_URL:-}" ]; then
            echo "Missing Jenkins configuration. Please set JENKINS_URL, JENKINS_USER, JENKINS_API_TOKEN, and JENKINS_JOB_URL secrets." >&2
            exit 1
          fi

          JENKINS_URL="${JENKINS_URL%/}"
          JENKINS_JOB_URL="${JENKINS_JOB_URL%/}/"

          CRUMB_HEADER=()
          CRUMB_RESPONSE=$(curl -sf -u "$JENKINS_USER:$JENKINS_API_TOKEN" "$JENKINS_URL/crumbIssuer/api/json" || true)
          if [ -n "$CRUMB_RESPONSE" ]; then
            CRUMB=$(echo "$CRUMB_RESPONSE" | jq -r '.crumb // empty' 2>/dev/null || true)
            if [ -n "$CRUMB" ] && [ "$CRUMB" != "null" ]; then
              CRUMB_HEADER=(-H "Jenkins-Crumb: $CRUMB")
            else
              echo "Jenkins crumb endpoint returned no crumb; continuing without CSRF header."
            fi
          else
            echo "Jenkins crumb endpoint not reachable; continuing without CSRF header."
          fi

          if [ -n "${JENKINS_BUILD_TOKEN:-}" ]; then
            TRIGGER_URL="${JENKINS_JOB_URL}build?token=$JENKINS_BUILD_TOKEN"
          else
            TRIGGER_URL="${JENKINS_JOB_URL}build"
          fi

          RESPONSE_HEADERS=$(mktemp)
          HTTP_STATUS=$(curl -s -D "$RESPONSE_HEADERS" -o /dev/null -w "%{http_code}" \
            -u "$JENKINS_USER:$JENKINS_API_TOKEN" \
            "${CRUMB_HEADER[@]}" \
            -X POST "$TRIGGER_URL")

          if [ "${HTTP_STATUS:-0}" -ge 400 ]; then
            echo "Failed to trigger Jenkins job. HTTP status: $HTTP_STATUS" >&2
            cat "$RESPONSE_HEADERS" >&2 || true
            rm "$RESPONSE_HEADERS"
            exit 1
          fi

          QUEUE_URL=$(awk 'tolower($1) == "location:" {print $2}' "$RESPONSE_HEADERS" | tr -d '\r\n')
          rm "$RESPONSE_HEADERS"

          if [ -z "$QUEUE_URL" ]; then
            echo "Unable to trigger Jenkins job. Verify JENKINS_JOB_URL and credentials." >&2
            exit 1
          fi
          if [[ "$QUEUE_URL" == /* ]]; then
            QUEUE_URL="$JENKINS_URL$QUEUE_URL"
          fi
          echo "Triggered Jenkins queue item: $QUEUE_URL"

          BUILD_URL=""
          for attempt in $(seq 1 30); do
            sleep 10
            BUILD_URL=$(curl -s -u "$JENKINS_USER:$JENKINS_API_TOKEN" "${QUEUE_URL}api/json" | jq -r '.executable.url // empty')
            if [ -n "$BUILD_URL" ]; then
              if [[ "$BUILD_URL" == /* ]]; then
                BUILD_URL="$JENKINS_URL$BUILD_URL"
              fi
              echo "Jenkins build URL: $BUILD_URL"
              break
            fi
          done

          if [ -z "$BUILD_URL" ]; then
            echo "Timed out waiting for Jenkins build to start." >&2
            exit 1
          fi

          RESULT=""
          while [ -z "$RESULT" ] || [ "$RESULT" = "null" ]; do
            sleep 15
            RESULT=$(curl -s -u "$JENKINS_USER:$JENKINS_API_TOKEN" "${BUILD_URL}api/json" | jq -r '.result // empty')
            echo "Jenkins build status: ${RESULT:-IN_PROGRESS}"
          done

          if [ "$RESULT" != "SUCCESS" ]; then
            echo "Jenkins build finished with status $RESULT" >&2
            exit 1
          fi

          echo "Jenkins tests completed successfully."

  build-and-push:
    name: Build and push Docker images
    needs: jenkins-tests
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    outputs:
      backend-image: ${{ steps.image-tags.outputs.backend }}
      frontend-image: ${{ steps.image-tags.outputs.frontend }}
    steps:
      - uses: actions/checkout@v4

      - name: Determine deployment providers
        id: providers
        env:
          REGISTRY_PROVIDER: ${{ secrets.REGISTRY_PROVIDER }}
          K8S_PROVIDER: ${{ secrets.K8S_PROVIDER }}
        run: |
          REGISTRY=$(echo "${REGISTRY_PROVIDER:-ecr}" | tr '[:upper:]' '[:lower:]')
          KUBERNETES=$(echo "${K8S_PROVIDER:-eks}" | tr '[:upper:]' '[:lower:]')

          case "$REGISTRY" in
            ecr|dockerhub|acr|gcr) ;;
            *)
              echo "Unsupported registry provider: $REGISTRY. Choose ecr, dockerhub, acr, or gcr." >&2
              exit 1
              ;;
          esac

          case "$KUBERNETES" in
            eks|aks|gke) ;;
            *)
              echo "Unsupported Kubernetes provider: $KUBERNETES. Choose eks, aks, or gke." >&2
              exit 1
              ;;
          esac

          echo "registry=$REGISTRY" >> "$GITHUB_OUTPUT"
          echo "kubernetes=$KUBERNETES" >> "$GITHUB_OUTPUT"
          echo "REGISTRY_PROVIDER=$REGISTRY" >> "$GITHUB_ENV"
          echo "K8S_PROVIDER=$KUBERNETES" >> "$GITHUB_ENV"

      - name: Configure AWS credentials
        if: steps.providers.outputs.registry == 'ecr'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Log in to Amazon ECR
        if: steps.providers.outputs.registry == 'ecr'
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Log in to Docker Hub
        if: steps.providers.outputs.registry == 'dockerhub'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Log in to Azure Container Registry
        if: steps.providers.outputs.registry == 'acr'
        uses: azure/docker-login@v1
        with:
          login-server: ${{ secrets.AZURE_ACR_LOGIN_SERVER }}
          username: ${{ secrets.AZURE_ACR_USERNAME }}
          password: ${{ secrets.AZURE_ACR_PASSWORD }}

      - name: Authenticate to Google Cloud
        if: steps.providers.outputs.registry == 'gcr'
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}

      - name: Set up gcloud
        if: steps.providers.outputs.registry == 'gcr'
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}

      - name: Configure Docker for Google Artifact/Container Registry
        if: steps.providers.outputs.registry == 'gcr'
        env:
          GCP_REGISTRY_HOST: ${{ secrets.GCP_REGISTRY_HOST }}
        run: |
          if [ -z "${GCP_REGISTRY_HOST:-}" ]; then
            echo "GCP_REGISTRY_HOST secret must be provided when using gcr as the registry provider." >&2
            exit 1
          fi
          gcloud auth configure-docker "$GCP_REGISTRY_HOST" --quiet

      - name: Set image tags
        id: image-tags
        env:
          REGISTRY_URL: ${{ secrets.CONTAINER_REGISTRY }}
          BACKEND_NAME: ${{ secrets.BACKEND_IMAGE_NAME }}
          FRONTEND_NAME: ${{ secrets.FRONTEND_IMAGE_NAME }}
          AWS_ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        run: |
          REGISTRY="${REGISTRY_URL:-$AWS_ECR_REGISTRY}"
          REGISTRY="${REGISTRY%/}"
          if [ -z "$REGISTRY" ]; then
            echo "Container registry URL is missing. Provide CONTAINER_REGISTRY or ensure the registry login action outputs it." >&2
            exit 1
          fi
          if [ -z "$BACKEND_NAME" ] || [ -z "$FRONTEND_NAME" ]; then
            echo "BACKEND_IMAGE_NAME and FRONTEND_IMAGE_NAME secrets must be set." >&2
            exit 1
          fi
          echo "backend=$REGISTRY/$BACKEND_NAME:${GITHUB_SHA}" >> "$GITHUB_OUTPUT"
          echo "backend_latest=$REGISTRY/$BACKEND_NAME:latest" >> "$GITHUB_OUTPUT"
          echo "frontend=$REGISTRY/$FRONTEND_NAME:${GITHUB_SHA}" >> "$GITHUB_OUTPUT"
          echo "frontend_latest=$REGISTRY/$FRONTEND_NAME:latest" >> "$GITHUB_OUTPUT"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push backend image
        uses: docker/build-push-action@v6
        with:
          context: ./server
          file: ./server/Dockerfile
          push: true
          tags: |
            ${{ steps.image-tags.outputs.backend }}
            ${{ steps.image-tags.outputs.backend_latest }}

      - name: Build and push frontend image
        uses: docker/build-push-action@v6
        with:
          context: ./cc
          file: ./cc/Dockerfile
          push: true
          tags: |
            ${{ steps.image-tags.outputs.frontend }}
            ${{ steps.image-tags.outputs.frontend_latest }}
          build-args: |
            REACT_APP_API_BASE_URL=${{ secrets.REACT_APP_API_BASE_URL }}

  deploy:
    name: Deploy to Kubernetes
    needs: build-and-push
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Determine deployment providers
        id: deploy-providers
        env:
          REGISTRY_PROVIDER: ${{ secrets.REGISTRY_PROVIDER }}
          K8S_PROVIDER: ${{ secrets.K8S_PROVIDER }}
        run: |
          REGISTRY=$(echo "${REGISTRY_PROVIDER:-ecr}" | tr '[:upper:]' '[:lower:]')
          KUBERNETES=$(echo "${K8S_PROVIDER:-eks}" | tr '[:upper:]' '[:lower:]')

          case "$REGISTRY" in
            ecr|dockerhub|acr|gcr) ;;
            *)
              echo "Unsupported registry provider: $REGISTRY. Choose ecr, dockerhub, acr, or gcr." >&2
              exit 1
              ;;
          esac

          case "$KUBERNETES" in
            eks|aks|gke) ;;
            *)
              echo "Unsupported Kubernetes provider: $KUBERNETES. Choose eks, aks, or gke." >&2
              exit 1
              ;;
          esac

          echo "registry=$REGISTRY" >> "$GITHUB_OUTPUT"
          echo "kubernetes=$KUBERNETES" >> "$GITHUB_OUTPUT"
          echo "REGISTRY_PROVIDER=$REGISTRY" >> "$GITHUB_ENV"
          echo "K8S_PROVIDER=$KUBERNETES" >> "$GITHUB_ENV"

      - name: Configure AWS credentials
        if: steps.deploy-providers.outputs.kubernetes == 'eks'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Azure login
        if: steps.deploy-providers.outputs.kubernetes == 'aks'
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Authenticate to Google Cloud
        if: steps.deploy-providers.outputs.kubernetes == 'gke'
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}

      - name: Set up gcloud
        if: steps.deploy-providers.outputs.kubernetes == 'gke'
        uses: google-github-actions/setup-gcloud@v2
        with:
          project_id: ${{ secrets.GCP_PROJECT_ID }}

      - name: Get GKE credentials
        if: steps.deploy-providers.outputs.kubernetes == 'gke'
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: ${{ secrets.GKE_CLUSTER_NAME }}
          location: ${{ secrets.GKE_LOCATION }}

      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: v1.30.0

      - name: Update kubeconfig for EKS
        if: steps.deploy-providers.outputs.kubernetes == 'eks'
        env:
          CLUSTER_NAME: ${{ secrets.EKS_CLUSTER_NAME }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          if [ -z "$CLUSTER_NAME" ]; then
            echo "EKS_CLUSTER_NAME secret is not set." >&2
            exit 1
          fi
          aws eks update-kubeconfig --name "$CLUSTER_NAME" --region "$AWS_REGION"

      - name: Update kubeconfig for AKS
        if: steps.deploy-providers.outputs.kubernetes == 'aks'
        env:
          AZURE_RESOURCE_GROUP: ${{ secrets.AZURE_RESOURCE_GROUP }}
          AZURE_AKS_CLUSTER: ${{ secrets.AZURE_AKS_CLUSTER }}
        run: |
          if [ -z "$AZURE_RESOURCE_GROUP" ] || [ -z "$AZURE_AKS_CLUSTER" ]; then
            echo "AZURE_RESOURCE_GROUP and AZURE_AKS_CLUSTER secrets must be set for AKS deployments." >&2
            exit 1
          fi
          az aks get-credentials --resource-group "$AZURE_RESOURCE_GROUP" --name "$AZURE_AKS_CLUSTER" --overwrite-existing

      - name: Sync MongoDB secret
        env:
          NAMESPACE: campusconnect
          MONGO_URI: ${{ secrets.K8S_MONGO_URI }}
        run: |
          if [ -z "${MONGO_URI:-}" ]; then
            echo "K8S_MONGO_URI secret must be provided to deploy the backend." >&2
            exit 1
          fi
          kubectl -n "$NAMESPACE" create secret generic mongo-credentials \
            --from-literal=mongo-uri="$MONGO_URI" \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Apply Kubernetes manifests
        env:
          NAMESPACE: campusconnect
          BACKEND_IMAGE: ${{ needs.build-and-push.outputs.backend-image }}
          FRONTEND_IMAGE: ${{ needs.build-and-push.outputs.frontend-image }}
        run: |
          set -euo pipefail
          kubectl apply -k k8s
          kubectl -n "$NAMESPACE" set image deployment/campusconnect-backend backend="$BACKEND_IMAGE"
          kubectl -n "$NAMESPACE" set image deployment/campusconnect-frontend frontend="$FRONTEND_IMAGE"
          kubectl -n "$NAMESPACE" rollout status deployment/campusconnect-backend --timeout=180s
          kubectl -n "$NAMESPACE" rollout status deployment/campusconnect-frontend --timeout=180s